# OpenFitter - Unity Runtime コンポーネント

## 概要

UnityでのRBFメッシュ変形とボーン変換を行うコアランタイムコンポーネント群。

## コンポーネント

### RBFDeformer.cs

Burstコンパイル済みジョブを使用したRBFベースのメッシュ変形。

### BoneDeformer.cs

BlenderからUnityリグへのボーンポーズ変換適用。

### BindPoseCorrector.cs

変形後のスキンメッシュバインドポーズ補正。

### OpenFitterController.cs

完全なフィッティングパイプラインの統合制御。

## 数学

### RBF変形（RBFDeformer.cs）

#### カーネル関数

```math
φ(r) = √(r² + ε²)
```

**直観的な説明**：

- `r`：頂点と制御点の間の「ワールド空間での実距離」（Unity単位）
- `ε`：「影響範囲の広さ」を決めるパラメータ
  - εが大きい → 遠くの制御点の影響も受ける（広範囲に滑らかに変形）
  - εが小さい → 近くの制御点だけが影響（局所的に鋭く変形）
- `√`（平方根）：距離の増加に対して「ほどよく減衰」する性質
  - 線形（r）より早く減衰、指数関数（e^r）よりゆっくり減衰
  - 3D空間で自然な変形を実現

**物理的イメージ**：
ゴム膜を複数の指で押した状態。各指（制御点）は周囲に影響を与え、遠い場所ほど影響が弱まります。εは「ゴムの硬さ」のようなもの。

#### 変位計算

ワールド空間の各頂点 v に対して：

```math
d(v) = Σᵢ wᵢ · φ(||v - cᵢ||) + p₀ + p₁·vₓ + p₂·vᵧ + p₃·vᵤ
```

**直観的な説明**：

- `d(v)`：頂点vが「どの方向にどれだけ動くか」（変位ベクトル、3次元）
- `Σᵢ wᵢ · φ(...)`：全制御点からの「重み付き影響の合計」
  - 制御点iが近い → φが大きい → 影響大
  - 重みwᵢが大きい → その制御点の影響力が強い
  - 全制御点の影響を足し合わせる（重ね合わせの原理）
- `cᵢ`：Blenderで設定した制御点の位置（ワールド座標）
- `p₀ + p₁·vₓ + p₂·vᵧ + p₃·vᵤ`：空間全体の「大域的な傾き」
  - p₀：全頂点を一律にずらす（オフセット補正）
  - p₁, p₂, p₃：X, Y, Z方向の傾斜（ねじれや傾き）

**計算の流れ**：

1. 頂点vをワールド座標に変換
2. 各制御点cᵢとの距離||v - cᵢ||を計算
3. 距離からカーネル値φを計算
4. 重みwᵢを掛けて影響度を算出
5. 全制御点の影響を合算
6. 多項式項（傾き）を加算
7. 結果をローカル座標に戻して頂点に適用

**例**：
制御点が3つ（胸、腰、肩）ある場合、衣装の各頂点は「最も近い制御点の影響を強く受けつつ、他の2点の影響も少し受ける」ことで、滑らかに変形します。

#### 座標変換

**Blender → Unity変換**：

```math
(x_b, y_b, z_b) → (-x_b, z_b, -y_b)
```

**直観的な説明**：

Blenderの座標系（右手系、Z-Up）とUnityの座標系（左手系、Y-Up）では軸の対応が異なるため変換が必要：

| Blender | 物理的意味 | Unity |
|---------|-----------|-------|
| +X | 右 | -X（左右反転） |
| +Y | 前 | -Z（前後反転） |
| +Z | 上 | +Y（上下一致） |

**なぜ反転が必要か**：

- X反転：右手系↔左手系の変換で鏡像関係になるため
- Y反転：Y軸とZ軸が入れ替わり、さらに向きも逆転

**視覚的イメージ**：
Blenderで前を向いているキャラクターをUnityにインポートすると、鏡に映したように左右が逆になり、さらに座標軸が90度回転します。

#### 多項式項補正

座標変換後、多項式係数は調整が必要：

```
Unity入力座標: (x_u, y_u, z_u)
これをBlender座標に戻すと: (-x_u, -z_u, y_u)

多項式項の変換:
- p₁（X係数） → -p₁  （X反転の影響）
- p₂（Y係数） → p₃   （Y↔Z入れ替え）
- p₃（Z係数） → -p₂  （Y↔Z入れ替え + 反転）
```

**直観的な説明**：

Blenderで設定した「X方向の傾き」は、Unityでは「-X方向の傾き」になります。同様に、Blender のY方向の傾きはUnity のZ方向に、BlenderのZ方向の傾きはUnityの-Y方向に対応します。

**なぜ必要か**：
座標変換しただけでは、空間座標は正しく変換されますが、「その空間での方向性（傾き）」は自動的には変換されません。明示的に係数を入れ替える必要があります。

### ボーン変換（BoneDeformer.cs）

#### ワールド空間デルタ適用

各ボーンに対し、Blenderからの変換を適用：

```math
T_final = T_initial + Δt_world
```

**直観的な説明**：

- `T_initial`：Unityでの初期ボーン位置（ワールド座標）
- `Δt_world`：Blenderで計算された「移動量」（ワールド座標での差分）
- `T_final`：適用後の最終ボーン位置

**物理的イメージ**：
ボーンの根元が「初期位置からどれだけ移動したか」を単純に足し算。例えば腕を10cm上げたら、根元の位置も10cm上に移動。

```math
R_final = Δq_world × R_initial
```

**直観的な説明**：

- `R_initial`：初期回転姿勢（クォータニオン）
- `Δq_world`：Blenderからの「回転変化量」（クォータニオン）
- `R_final`：適用後の最終回転姿勢
- `×`：クォータニオンの積（回転の合成）

**物理的イメージ**：
初期姿勢から「さらにΔq_world分だけ回転する」操作。クォータニオン積は「回転Aをした後、回転Bをする」を表します。

**注意**：
クォータニオンは非可換（順序が重要）。`Δq × R`と`R × Δq`は一般に異なります。本実装ではワールド空間の回転なので`Δq × R`の順。

```math
S_final = S_initial ⊙ Δs_world
```

**直観的な説明**：

- `S_initial`：初期スケール（X, Y, Z方向の拡大率）
- `Δs_world`：Blenderからの「スケール変化率」
- `⊙`：要素ごとの積（Hadamard積）
  - (Sx, Sy, Sz) ⊙ (Δx, Δy, Δz) = (Sx·Δx, Sy·Δy, Sz·Δz)

**例**：
初期スケールが (1.0, 1.0, 1.0)、Δs_world が (1.0, 1.5, 1.0) なら、最終スケールは (1.0, 1.5, 1.0)。つまりY方向に1.5倍伸びます。

#### 回転変換

Blender Euler（XYZ固有） → Unity クォータニオン：

```
# Blenderクォータニオン構築（XYZ固有回転）
q_blend = Rz(θz) × Ry(θy) × Rx(θx)

# Unityクォータニオンマッピング
q_unity = (q_blend.x, -q_blend.z, q_blend.y, q_blend.w)
```

**直観的な説明**：

**Blender側の回転順序**：

1. X軸周りにθx度回転（ピッチ：上下の首振り）
2. Y軸周りにθy度回転（ヨー：左右の首振り）
3. Z軸周りにθz度回転（ロール：首のひねり）

**クォータニオン成分の対応**：

- `q.x`：X軸成分 → そのまま
- `q.y`：Y軸成分 → Unity の Z軸成分（軸入れ替え）
- `q.z`：Z軸成分 → Unity の -Y軸成分（軸入れ替え + 反転）
- `q.w`：スカラー成分 → そのまま

**なぜこうなるか**：
座標軸の対応に合わせてクォータニオンの成分も入れ替えます。回転軸が変わるため、成分も対応する軸に移動します。

#### ローカルスケール計算

親階層を考慮してターゲットワールドスケールを実現：

```math
localScale = targetLossyScale ÷ parentLossyScale
```

**直観的な説明**：

- `targetLossyScale`：実現したいワールド空間でのスケール
- `parentLossyScale`：親ボーンの現在のワールドスケール
- `localScale`：設定すべきローカルスケール値
- `÷`：要素ごとの除算

**なぜ除算が必要か**：
Unityでは子の最終スケールは「親のスケール × 子のローカルスケール」で計算されます。逆算して、

```
子のワールドスケール = 親のワールドスケール × 子のローカルスケール
→ 子のローカルスケール = 子のワールドスケール ÷ 親のワールドスケール
```

**例**：

- 親が2倍に拡大されている（parentLossyScale = 2.0）
- 子を1.5倍にしたい（targetLossyScale = 1.5）
- 子のlocalScaleは 1.5 ÷ 2.0 = 0.75 に設定

すると、実際のワールドスケールは 2.0 × 0.75 = 1.5 となり、目標通りになります。

## ロジック

### RBFDeformer パイプライン

1. **初期化**（`InitMeshes`）

   ```
   全SkinnedMeshRendererコンポーネントを検索（子階層含む）
   各メッシュのプレビューメッシュを作成（元メッシュは保持）
   元メッシュ → 変形メッシュのペアを追跡
   　理由：非破壊編集、いつでも元に戻せる
   ```

2. **データロード**（`LoadRBFData`）

   ```
   JSONをパースして centers, weights, poly_weights を取得
   Blender座標 → Unity座標に全点を変換
   多項式係数を軸入れ替えに合わせて調整
   永続NativeArray（GPU互換メモリ）を割当
   　理由：毎フレーム再割当を避け、高速化
   ```

3. **ジョブ実行**（`ApplyRBF`）

   ```
   FOR each 頂点 IN メッシュ（並列処理）:
     頂点をワールド空間に変換（localToWorld行列）
     全制御点との距離を計算
     RBFカーネル値を計算: φ(distance)
     重み付き寄与を合算: Σ wᵢ · φᵢ
     多項式項を追加: + p₀ + p₁·x + p₂·y + p₃·z
     変位をローカル空間に戻す（inverseRotation）
     元の頂点位置 + 変位 = 新しい頂点位置
   ```

4. **メッシュ更新**

   ```
   変形頂点をメッシュに書込
   法線を再計算（照明が正しく当たるように）
   バウンズを更新（カリング最適化）
   ```

### BoneDeformer パイプライン

1. **初期化**（`InitializeBoneMap`）

   ```
   rootTransformから全子ボーンを再帰的に探索
   各ボーンの名前 → Transformのマップを作成
   初期ワールド変換（position, rotation, lossyScale）をキャッシュ
   初期ローカル変換（localPosition, localRotation, localScale）をキャッシュ
   　理由：リセット機能、デバッグ用
   ```

2. **ポーズ適用**（`ApplyPose`）

   ```
   JSONボーンデータをロード
   rootから再帰的にボーンを処理（親優先）
   　理由：子のスケール計算は親のワールドスケールが必要
   名前プレフィックスマッチング処理（"Armature:Bone" → "Bone"）
   　理由：Blenderの命名規則に対応
   ```

3. **ボーン単位の変換**（`ApplyTransformToBone`）

   ```
   ワールド位置デルタを初期位置に加算
   デルタ回転を初期回転に合成（クォータニオン積）
   ターゲットワールドスケールを計算（初期 × デルタ）
   親のワールドスケールで除算してローカルスケール算出
   Transformコンポーネントに反映
   ```

4. **リセット**（`ResetPose`）

   ```
   全ボーンのローカル変換をキャッシュ値に復元
   　用途：変形前後の比較、デバッグ、やり直し
   ```

## 機能

### RBFDeformer コンポーネント

**インスペクタフィールド**：

- `rbfDataJson`：RBFデータを含むTextAsset
  - BlenderでエクスポートしたJSONファイルをドラッグ＆ドロップ
- `targets`：ターゲットメッシュリスト（自動入力）
  - 変形対象のSkinnedMeshRenderer一覧（読取専用）

**公開メソッド**：

- `RunDeformationInEditor()`：完全パイプライン実行
  - 初期化 → ロード → 変形 → 適用を一括実行
- `DisposeNativeArrays()`：手動クリーンアップ
  - メモリリーク防止、スクリプト再コンパイル時に自動呼出

**特徴**：

- **自動子メッシュ検出**：階層下の全メッシュを自動で対象化
- **プレビューメッシュシステム**：元メッシュを破壊しない
- **Burstコンパイル並列ジョブ**：マルチコアCPUで高速処理
- **永続データキャッシング**：一度ロードしたら再利用

### BoneDeformer コンポーネント

**インスペクタフィールド**：

- `poseDataJson`：ボーンポーズを含むTextAsset
- `rootTransform`：アーマチュアルート（自動検出）
  - 未設定時は自分自身のTransformを使用
- `boneLengthAxis`：ボーン方向（Y/Z/X）
  - Blender標準はY、Unity人型リグはZ

**公開メソッド**：

- `ApplyPose()`：ボーン変換適用
- `ResetPose()`：初期ポーズ復元

**特徴**：

- **階層的ボーン処理**：親から子へ順番に処理
- **名前プレフィックス処理**：`Armature:Bone`形式に対応
- **ワールド空間デルタ適用**：親の変形に影響されない
- **初期状態保存**：何度でもやり直し可能

### BindPoseCorrector コンポーネント

ボーン変換後のスキンメッシュバインディング修正。

**ロジック**：

```
現在のボーン行列をキャプチャ
メッシュのbindposes配列を更新（逆行列）
ボーンウェイトが新しいボーン位置に対応
　効果：メッシュが正しくボーンに追従
```

### OpenFitterController コンポーネント

RBF + ボーン変形を統合するマスターコントローラー。

**ワークフロー**：

```
1. ボーン変換を適用（骨格を動かす）
2. RBFメッシュ変形を適用（肉付けを調整）
3. バインドポーズを補正（スキニングを修正）
4. 結果をプレハブとして保存
```

## 技術詳細

### パフォーマンス最適化

**Burstコンパイル**：

```csharp
[BurstCompile]
struct RBFDeformJob : IJobParallelFor
```

- **SIMD（Single Instruction Multiple Data）ベクトル化**
  - 1命令で4つの頂点を同時処理
- **マルチスレッドメッシュ処理**
  - 全CPUコアを活用
- **ホットパスでのマネージド割当ゼロ**
  - ガベージコレクション停止なし

**ジョブ並列化**：

```csharp
job.Schedule(vertexCount, batchSize: 64)
```

- 64頂点ごとにバッチ処理
- スレッド間でバッチを分散
- キャッシュラインに最適化

**期待性能**：

- 1000頂点メッシュ：< 1ms
- 10000頂点メッシュ：< 10ms
- 100制御点、8コアCPU環境

### メモリ管理

**NativeArrayライフサイクル**：

```csharp
Allocator.Persistent → OnDisable/OnDestroy で Dispose
```

- **Persistent割当**：ゲームループ中ずっと保持
- **自動破棄**：コンポーネント削除時に自動クリーンアップ
- **再利用**：複数変形で同じメモリを使い回し

**プレビューメッシュ**：

```csharp
hideFlags = HideFlags.DontSaveInEditor | HideFlags.DontSaveInBuild
```

- **エディタ非保存**：シーンファイルに保存されない
- **ビルド非含有**：実行ファイルに含まれない
- **効果**：プロジェクトサイズ削減、エディタ高速化

### 座標空間処理

**RBF計算**：

```
制御点：ワールド空間（Blenderエクスポート時の座標系）
入力頂点：ワールド空間（localToWorld行列で変換）
出力変位：ワールド空間（カーネル計算結果）
最終適用：ローカル空間（inverseRotation で戻す）
```

**ボーン変換**：

```
デルタ値：ワールド空間（Blenderで計算）
適用先：ワールド空間bone.position/rotation
保存形式：ローカル変換bone.localPosition/localRotation
　理由：Unityの階層システム要件
```

## エラー処理

### RBFDeformer

```
JSONなし → Debug.LogError、処理中止
無効なcenters（空配列） → 警告ログ、スキップ
破棄済み配列アクセス → 次回実行時に自動再作成
```

### BoneDeformer

```
ボーン未発見 → サイレントスキップ（エラーなし）
　理由：オプショナルボーン対応
親ボーンなし（root） → 単位スケール使用
無効なJSON → Debug.LogError、処理中止
```

## 依存関係

- Unity.Jobs（並列処理フレームワーク）
- Unity.Collections（NativeArray等）
- Unity.Mathematics（float3, quaternion等）
- Unity.Burst（AOTコンパイラ）
- Newtonsoft.Json（JSONパーサー）
