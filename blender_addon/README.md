# OpenFitter Blenderアドオン

## 概要

UnityのOpenFitterシステムで使用する変形データをエクスポートするBlenderツール群。

## コンポーネント

### RBFフィールドエクスポーター (`rbf_exporter.py`)

シェイプキーから放射基底関数（RBF）変形フィールドをエクスポート。

### ボーンポーズエクスポーター (`bone_exporter.py`)

アーマチュア間のボーン変形差分をエクスポート。

## 数学

### RBF（Radial Basis Function - 放射基底関数）補間

**RBFとは**：
入力点からの距離に基づいて値を返す関数。データ補間、機械学習（SVMカーネル）、画像ワープ、3Dメッシュ変形など広く使用される。

**本プロジェクトでの用途**：
異なる体型のアバター間で衣装メッシュを変形させる際、「基準体型での変形」から「任意の衣装メッシュへの変形」を空間全体で滑らかに補間計算。

コアは**多重二次調和カーネル**（Multi-Quadratic Biharmonic）を使用：

```math
φ(r) = √(r² + ε²)
```

**直観的な説明**：

- `r`：測定したい点と制御点の間の直線距離（単位：メートルやセンチメートル）
- `ε`（イプシロン）：「影響範囲の広さ」を調整するパラメータ
  - εが大きい → 遠くまで滑らかに影響が広がる（柔らかい変形）
  - εが小さい → 制御点の近くだけ影響（鋭い変形、局所的）
- `√`（平方根）がある理由：距離に応じて「ちょうどよく減衰」する性質を持つため、3D空間での滑らかな変形に適している

**物理的イメージ**：
石を池に投げ入れたときの波紋のように、制御点から距離に応じて「影響が弱まる」様子を数式化したもの。εは水の粘性のようなもので、大きいほど広範囲にゆっくり広がります。

#### 補間式

ソース点 S = {s₁, s₂, ..., sₙ} とターゲット点 T = {t₁, t₂, ..., tₙ} が与えられた場合：

```math
d(s) = Σᵢ wᵢ · φ(||s - sᵢ||) + p₀ + p₁·x + p₂·y + p₃·z
```

**直観的な説明**：

- `d(s)`：任意の点sにおける「変位ベクトル」（どの方向にどれだけ動かすか）
- `Σᵢ wᵢ · φ(...)`：全ての制御点からの「重み付き影響」の合計
  - 各制御点が「その距離に応じた強さ」で引っ張る力の総和
  - wᵢは「どれだけ強く引っ張るか」の係数
- `p₀ + p₁·x + p₂·y + p₃·z`：全体的な傾き補正（線形項）
  - p₀：全体を一律にずらす（オフセット）
  - p₁, p₂, p₃：空間全体に傾斜をかける（大域的な変形傾向）

**例**：
制御点が3つある場合、点sでの変形は「3つの制御点それぞれから距離に応じた力を受け、それらを合成した結果」になります。近い制御点ほど強く影響します。

#### システム行列

重みは以下の線形方程式系で解く：

```math
| Φ   P | | w |   | Δ |
| Pᵀ  0 | | p | = | 0 |
```

**直観的な説明**：

- `Φ`（カーネル行列）：制御点同士の「相互影響度」を表すN×N行列
  - Φᵢⱼ = 制御点iとjの距離から計算される影響度
  - 対角成分Φᵢᵢ = ε（自分自身との距離は0なので）
- `P`（多項式基底）：各制御点の座標 [1, x, y, z] を並べたN×4行列
  - 空間全体の傾きを捉えるため
- `w`：求めたい「重み」ベクトル（N個）
  - 各制御点がどれだけ強く引っ張るか
- `p`：求めたい「多項式係数」（4個：p₀, p₁, p₂, p₃）
- `Δ`：制御点での「実際の変位」（ターゲット - ソース）

**なぜこの形か**：
下段の `Pᵀw = 0` という制約により、重みベクトルwが「空間全体で偏らない」ことを保証。これにより、遠方で変形が暴走せず安定します。

#### 平滑化正則化

安定性向上のため対角に追加：

```math
Φ + λI
```

**直観的な説明**：

- `λ`（ラムダ）：「滑らかさの強制度」を調整するパラメータ
  - λ = 0 → 制御点の変形を完全に再現（ノイズに敏感、不安定）
  - λ > 0 → 少し誤差を許容して滑らかな解を優先（安定、頑健）
- `I`：単位行列（対角成分だけ1、他は0）

**物理的イメージ**：
制御点ぴったりに合わせようとすると「ガタガタの曲面」になりがち。λを加えることで「多少のズレは許容して、全体が滑らかな曲面」になるよう調整します。写真のノイズ除去フィルタに似ています。

### イプシロン推定

平均最近傍距離に基づく自動イプシロン計算：

```math
ε = 1.5 × mean(min_dist(vᵢ, V \ {vᵢ}))
```

**直観的な説明**：

- `min_dist(vᵢ, V \ {vᵢ})`：頂点iから「最も近い他の頂点」までの距離
- `mean(...)`：全頂点での平均を取る
- `1.5×`：平均の1.5倍に設定（経験的に良い値）

**なぜこの式か**：
メッシュの頂点間隔（密度）に応じて自動調整。

- 頂点が密集（細かいメッシュ） → εは小さく（局所的な変形）
- 頂点がまばら（粗いメッシュ） → εは大きく（広範囲の変形）

これにより、メッシュ解像度に関わらず安定した補間が可能になります。

### ボーン変形の数学

#### デルタ行列計算

各ボーンについて、ワールド空間での変形差分を計算：

```math
M_delta = M_transformed × M_rest⁻¹
```

**直観的な説明**：

- `M_rest`：レストポーズ（初期姿勢）でのボーンの「ワールド空間での位置・向き・大きさ」を表す4×4行列
- `M_transformed`：ポーズ適用後のボーンの「ワールド空間での位置・向き・大きさ」
- `M_rest⁻¹`：レストポーズ行列の逆行列（「元に戻す操作」）
- `M_delta`：「どう変形したか」の差分行列

**物理的イメージ**：

1. レストポーズから見て、ボーンがどう動いたか？
2. `M_rest⁻¹`で「レストポーズ基準の座標系」に戻す
3. `M_transformed`で「変形後の座標系」に変換
4. 結果の`M_delta`が「純粋な変形成分」

**例**：
腕を下から横に90度上げた場合、M_deltaには「Y軸周りに90度回転」という情報が入ります。

#### 分解

TRS成分を抽出：

```math
t = head_transformed - head_rest  （移動）
```

**直観的な説明**：

- `head_rest`：レストポーズでのボーンの「根元位置」（ワールド座標）
- `head_transformed`：変形後のボーンの「根元位置」
- `t`：根元がどれだけ移動したか（ベクトル）

単純な引き算で、「どこからどこへ移動したか」が一目瞭然。

```math
R = euler(M_delta)  （回転）
```

**直観的な説明**：

- `M_delta`から回転成分だけを取り出し、オイラー角（X軸、Y軸、Z軸周りの回転角度）に変換
- オイラー角は「どの軸を何度回すか」が直観的に分かる表現

```math
S = scale(M_delta)  （スケール）
```

**直観的な説明**：

- M_deltaからスケール成分（X, Y, Z方向の拡大率）を抽出
- 例：S = (1.0, 1.5, 1.0) なら「Y方向に1.5倍伸びた」

#### 座標系

Blender（右手系、Z-Up）：

- X = 右
- Y = 前
- Z = 上

**直観的イメージ**：
右手を前に伸ばした状態で、

- 親指（X）= 右方向
- 人差し指（Y）= 前方向
- 中指（Z）= 上方向

## ロジック

### RBFエクスポートパイプライン

1. **シェイプキー抽出**

   ```
   "Basis"シェイプ（元メッシュ）を読込
   "Target"シェイプ（フィッティング後メッシュ）を読込
   各頂点のデルタ（変位ベクトル）を計算: delta = target - basis
   ```

2. **点フィルタリング**

   ```
   IF |delta| < 0.0001 THEN 除外
     理由：ほぼ動いてない頂点は計算コスト削減のため除外
   
   IF enable_x_mirror THEN X軸ミラーリング適用
     理由：左右対称なメッシュで制御点を倍増させ精度向上
   
   ボクセルグリッドダウンサンプリング（間隔 = ε × 0.2）
     理由：近すぎる点は冗長なので空間的に間引く
   
   IF points > max_points THEN ランダムダウンサンプリング
     理由：計算量削減（N^2なので点数制限が必須）
   ```

3. **RBFフィッティング**

   ```
   カーネル行列Φを構築（N×N、各要素は点間距離から計算）
   平滑化正則化を追加: Φ' = Φ + λI（数値安定性）
   線形方程式を解く: Ax = b（連立方程式、行列演算）
   weights, poly_weightsを抽出（制御点の重みと多項式係数）
   ```

4. **決定性保証**

   ```
   固定乱数シード（42）で再現可能なサンプリング
     理由：同じ入力から毎回同じ結果を保証
   
   ソート済みグリッドインデックスで一貫した順序
     理由：ハッシュマップのランダムな順序を排除
   ```

### ボーンエクスポートパイプライン

1. **アーマチュア検証**

   ```
   IF active_object.type != 'ARMATURE' THEN エラー
     理由：ボーンのないオブジェクトではエクスポート不可
   ```

2. **ボーン単位の処理**

   ```
   FOR each bone IN armature.pose.bones:
     # ローカル基底値（Blender UI表示値と同じ）
     location = bone.location  
     rotation = bone.rotation_euler/quaternion
     scale = bone.scale
     
     # ワールド空間での実際の変形量を計算
     M_rest = armature.data.bones[bone.name].matrix_local
     M_pose = bone.matrix
     M_delta = (armature.matrix_world @ M_pose) @ (armature.matrix_world @ M_rest)⁻¹
     
     # JSONに保存
     出力: location, rotation, scale, delta_matrix
   ```

3. **JSONエクスポート**

   ```
   ボーン名をキーとして各ボーンデータを保存
   デバッグ用参照行列を含める（head_world など）
   ```

## 機能

### RBFエクスポーターUI

**パネル**：View3D → サイドバー → OpenFitter → RBF Field Export

**パラメータ**：

- `Basis Key`：元シェイプキー
- `Target Key`：変形後シェイプキー
- `Epsilon`：RBFカーネル幅（自動推定可能）
  - 小さい値：局所的な鋭い変形
  - 大きい値：広範囲の滑らかな変形
- `Smoothing`：正則化強度（0.0 - 1.0）
  - 0.0：制御点に完全一致（ノイズに敏感）
  - 0.1：少し滑らか（推奨）
  - 1.0：かなり滑らか（細部が失われる）
- `Max Points`：制御点上限（デフォルト500）
  - 少ない：高速だが粗い変形
  - 多い：精密だが低速
- `X Mirror`：対称ミラーリング有効化
  - 左右対称メッシュで有効化推奨

**オペレーター**：

- `Estimate Epsilon`：最適イプシロンを自動計算
  - メッシュ密度に応じた適切な値を推定
- `Export RBF JSON`：変形フィールドを保存

### ボーンエクスポーターUI

**パネル**：View3D → サイドバー → OpenFitter → Bone Pose Export

**使い方**：

1. ポーズモードでアーマチュアを選択
2. ボーンをターゲットポーズに配置
3. "Export Bone Pose JSON"をクリック
4. ファイルに保存

**出力形式**：

```json
{
  "BoneName": {
    "location": [x, y, z],
    "rotation": [rx, ry, rz],
    "scale": [sx, sy, sz],
    "head_world": [...],
    "head_world_transformed": [...],
    "delta_matrix": [[...], [...], [...], [...]]
  }
}
```

## 技術詳細

### メモリ最適化

- **ボクセルグリッドフィルタリング**：冗長な近傍点を防止
  - 空間をε×0.2間隔のグリッドに分割
  - 各グリッドセルから1点だけ選択
- **イプシロン推定時は1000頂点にサンプリング制限**
  - 大規模メッシュでも高速計算
- **効率的なメモリ処理のためNativeArray使用**
  - Unity側でのメモリアライメント最適化

### 数値安定性

- **特異行列の場合は最小二乗法フォールバック**
  - 制御点が一直線上などの退化ケース対策
- **正則化で悪条件を防止**
  - 条件数が大きい行列でも安定解
- **最小イプシロン閾値（0.001）**
  - ゼロ除算やオーバーフロー防止

### パフォーマンス

- **`foreach_get()`による高速バッチ頂点アクセス**
  - Pythonループより1000倍高速
- **NumPyベクトル化による距離計算**
  - SIMD命令を活用
- **並列対応アーキテクチャ**
  - Unity側でBurst並列ジョブに最適

## 依存関係

- Blender >= 2.80
- NumPy（Blender同梱）
- mathutils（Blender組込）
